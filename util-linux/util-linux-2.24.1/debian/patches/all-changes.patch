--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,3 @@
 See version control history.

-http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=log;h=2.24.1
+http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=log
--- a/fdisks/cfdisk.8
+++ b/fdisks/cfdisk.8
@@ -28,7 +28,7 @@
 .RI [ device ]
 .SH DESCRIPTION
 .B cfdisk
-is a curses-based program for partitioning any hard disk drive.
+is a curses/slang based program for partitioning any hard disk drive.
 Typical values of the
 .I device
 argument are:
--- a/misc-utils/getopt.1
+++ b/misc-utils/getopt.1
@@ -418,7 +418,7 @@
 distribution, and are optionally installed in
 .BR /usr/share/getopt/
 or
-.BR /usr/share/docs/
+.BR /usr/share/doc/util-linux/examples/
 in the util-linux subdirectory.
 .SH ENVIRONMENT
 .IP POSIXLY_CORRECT
--- a/sys-utils/hwclock.8
+++ b/sys-utils/hwclock.8
@@ -630,8 +630,6 @@
 .SH FILES
 .I /etc/adjtime
 .I /usr/share/zoneinfo/
-.RI ( /usr/lib/zoneinfo
-on old systems)
 .I /dev/rtc
 .I /dev/rtc0
 .I /dev/port
@@ -644,6 +642,8 @@
 .BR settimeofday (2),
 .BR crontab (1),
 .BR tzset (3)
+.BR /etc/init.d/hwclock.sh,
+.BR /usr/share/doc/util-linux/README.Debian.hwclock
 
 .SH AUTHORS
 Written by Bryan Henderson, September 1996 (bryanh@giraffe-data.com),
--- a/sys-utils/hwclock.c
+++ b/sys-utils/hwclock.c
@@ -1135,8 +1135,18 @@
 	if (!ur)
 		ur = probe_for_kd_clock();

+	/*
+	 * This final clause is a really bad idea on x86/AT PCs. You run the
+	 * risk of a race condition with another copy of hwclock
+	 * that already has /dev/rtc open. The fallback case on
+	 * x86 is to then raise I/O priviledge level and access
+	 * the RTC CMOS directly using I/O instructions. Simultaneous
+	 * access like that can really hose the RTC.
+	 */
+#if !defined(__i386__)
 	if (!ur && !user_requests_ISA)
 		ur = probe_for_cmos_clock();
+#endif

 	if (debug) {
 		if (ur)
--- a/lib/blkdev.c
+++ b/lib/blkdev.c
@@ -25,6 +25,10 @@
 #include <sys/disk.h>
 #endif
 
+#ifdef __FreeBSD_kernel__
+#include <sys/disk.h>
+#endif
+
 #include "blkdev.h"
 #include "c.h"
 #include "linux_version.h"
--- a/libblkid/blkid.pc.in
+++ b/libblkid/blkid.pc.in
@@ -1,5 +1,6 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
+libexecdir=@libexecdir@
 libdir=@usrlib_execdir@
 includedir=@includedir@

--- a/libmount/mount.pc.in
+++ b/libmount/mount.pc.in
@@ -1,5 +1,6 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
+libexecdir=@libexecdir@
 libdir=@usrlib_execdir@
 includedir=@includedir@

--- a/libuuid/uuid.pc.in
+++ b/libuuid/uuid.pc.in
@@ -1,5 +1,6 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
+libexecdir=@libexecdir@
 libdir=@usrlib_execdir@
 includedir=@includedir@

--- a/sys-utils/fstab.5
+++ b/sys-utils/fstab.5
@@ -63,7 +63,9 @@
 .BR umount (8)
 sequentially iterate through
 .B fstab
-doing their thing.
+doing their thing, though at boot time
+.BR mountall (8)
+may process the file out-of-order when it believes it is safe to do so.
 
 .B The first field
 .RI ( fs_spec ).
@@ -210,6 +212,27 @@
 do not report errors for this device if it does not exist.
 .RE
 
+The
+.BR mountall (8)
+program that mounts filesystem during boot also recognises additional
+options that the ordinary
+.BR mount (8)
+tool does not.  These are: ``bootwait'' which can be applied to remote
+filesystems mounted outside of
+.I /usr
+or
+.IR /var ,
+without which
+.BR mountall (8)
+would not hold up the boot for these; ``nobootwait'' which can be
+applied to non-remote filesystems to explicitly instruct
+.BR mountall (8)
+not to hold up the boot for them; ``optional'' which causes the entry
+to be ignored if the filesystem type is not known at boot time; and
+``showthrough'' which permits a mountpoint to be mounted before its
+parent mountpoint (this latter should be used carefully, as it can
+cause boot hangs).
+
 .B The fifth field
 .RI ( fs_freq ).
 .RS
@@ -258,6 +281,7 @@
 .SH "SEE ALSO"
 .BR findmnt (8),
 .BR mount (8),
+.BR mountall (8),
 .BR swapon (8),
 .BR fs (5),
 .BR getmntent (3)
--- a/mount-deprecated/fstab.c
+++ b/mount-deprecated/fstab.c
@@ -83,11 +83,12 @@

 /* Contents of mtab and fstab ---------------------------------*/

-struct mntentchn mounttable, fstab;
+struct mntentchn mounttable, fstab, mountall;
 static int got_mtab = 0;
 static int got_fstab = 0;
+static int got_mountall = 0;

-static void read_mounttable(void), read_fstab(void);
+static void read_mounttable(void), read_fstab(void), read_mountall(void);

 struct mntentchn *
 mtab_head() {
@@ -103,6 +104,14 @@
 	return &fstab;
 }

+struct mntentchn *
+mountall_head() {
+	if (!got_mountall)
+		read_mountall();
+	return &mountall;
+}
+
+
 static void
 my_free_mc(struct mntentchn *mc) {
 	if (mc) {
@@ -201,6 +210,27 @@
 	read_mntentchn(mfp, fnam, mc);
 }

+static void
+read_mountall() {
+	mntFILE *mfp = NULL;
+	const char *fnam;
+	struct mntentchn *mc = &mountall;
+
+	got_mountall = 1;
+	mc->nxt = mc->prev = NULL;
+
+	fnam = "/lib/init/fstab";
+	mfp = my_setmntent (fnam, "r");
+	if (mfp == NULL || mfp->mntent_fp == NULL) {
+		int errsv = errno;
+		error(_("warning: can't open %s: %s"),
+		      fnam, strerror (errsv));
+		return;
+	}
+	read_mntentchn(mfp, fnam, mc);
+}
+
+

 /* Given the name NAME, try to find it in mtab.  */
 struct mntentchn *
@@ -273,9 +303,11 @@
 			return mc;
 	}

-	/* non-canonical names in mtab (this is BAD THING!) */
+	/* non-canonical names in mtab (this is BAD THING!)
+	 * but it should be allowed only for spec fsname(s)
+	 */
 	for (mc = mcprev->prev; mc && mc != mc0; mc = mc->prev) {
-		char *cn = canonicalize(mc->m.mnt_fsname);
+		char *cn = canonicalize_spec(mc->m.mnt_fsname);
 		int res = cn ? streq(cn, name) : 0;

 		free(cn);
@@ -286,6 +318,19 @@
 	return NULL;
 }

+/* Given the directory name DIR, try to find it in mountall's fstab.  */
+struct mntentchn *
+getmountalldir (const char *dir) {
+	struct mntentchn *mc, *mc0;
+
+	mc0 = mountall_head();
+	for (mc = mc0->nxt; mc && mc != mc0; mc = mc->nxt)
+		if (streq(mc->m.mnt_dir, dir))
+			return mc;
+	return NULL;
+}
+
+
 /*
  * Given the name NAME, check that it occurs precisely once as dir or dev.
  */
--- a/mount-deprecated/fstab.h
+++ b/mount-deprecated/fstab.h
@@ -29,6 +29,9 @@
 struct mntentchn *getfs_by_uuid (const char *uuid);
 struct mntentchn *getfs_by_label (const char *label);

+struct mntentchn *mountall_head (void);
+struct mntentchn *getmountalldir (const char *dir);
+
 void lock_mtab (void);
 void unlock_mtab (void);
 void update_mtab (const char *special, struct my_mntent *with);
--- a/mount-deprecated/mount.8
+++ b/mount-deprecated/mount.8
@@ -149,7 +149,7 @@
 more readable, robust and portable. The
 .BR mount (8)
 command internally uses udev
-symlinks, so use the symlinks in /etc/fstab has no advantage over LABEL=/UUID=.
+symlinks, so the use symlinks in /etc/fstab has no advantage over LABEL=/UUID=.
 For more details see
 .BR libblkid (3).
 
@@ -1951,7 +1951,7 @@
 .SH "Mount options for nfs and nfs4"
 See the options section of the
 .BR nfs (5)
-man page (nfs-utils package must be installed).
+man page (nfs-common package must be installed).
 
 The
 .IR nfs " and " nfs4
--- a/mount-deprecated/mount.c
+++ b/mount-deprecated/mount.c
@@ -62,6 +62,9 @@
 /* True for explicit readonly (-r).  */
 static int readonly = 0;
 
+/* Nonzero for chatty (-v).  */
+int verbose = 0;
+
 /* Nonzero for sloppy (-s).  */
 static int sloppy = 0;
 
@@ -196,6 +199,10 @@
   { "nostrictatime", 0, 1, MS_STRICTATIME }, /* kernel default atime */
 #endif
   { "nofail",	0, 0, MS_COMMENT, MS_COMMENT_NOFAIL },	/* Do not fail if ENOENT on dev */
+  { "bootwait",	0, 0, MS_COMMENT },
+  { "nobootwait", 0, 0, MS_COMMENT },
+  { "optional",	0, 0, MS_COMMENT },
+  { "showthrough", 0, 0, MS_COMMENT },
   { NULL,	0, 0, 0		}
 };
 
@@ -692,7 +699,7 @@
 		mnt.mnt_freq = mnt.mnt_passno = 0;
 		free(extra_opts);
 
-		if (my_addmntent (mfp, &mnt) == 1) {
+		if (mnt.mnt_fsname && my_addmntent (mfp, &mnt) == 1) {
 			int errsv = errno;
 			die (EX_FILEIO, _("mount: error writing %s: %s"),
 			     _PATH_MOUNTED, strerror (errsv));
@@ -2345,6 +2352,15 @@
 	if (!mc && (devname || spec))
 		mc = getmntfilebackward (devname ? devname : spec, NULL);
 
+	/*
+	 * E) try /lib/init/fstab
+	 *    These are things mounted by mountall, unless overridden by
+	 *    just about everything else -- it makes sense to use it here
+	 *    too so "mount /sys" just works.
+	 */
+	if (!mc && spec)
+		mc = getmountalldir (spec);
+
 	my_free(devname);
 	return mc;
 }
@@ -2402,7 +2418,7 @@
 	initproctitle(argc, argv);
 #endif
 
-	while ((c = getopt_long (argc, argv, "aBfFhilL:Mno:O:p:rRsU:vVwt:",
+	while ((c = getopt_long (argc, argv, "aBfFhi:lL:Mno:O:p:rRsU:vVwt:",
 				 longopts, NULL)) != -1) {
 		switch (c) {
 		case 'a':	       /* mount everything in fstab */
--- a/sys-utils/ipcs.c
+++ b/sys-utils/ipcs.c
@@ -461,8 +461,10 @@
 			return;
 		}
 		printf (_("------ Messages Status --------\n"));
+#ifndef __FreeBSD_kernel__
 		printf (_("allocated queues = %d\n"), msginfo.msgpool);
 		printf (_("used headers = %d\n"), msginfo.msgmap);
+#endif
 		ipc_print_size(unit, _("used space"), msginfo.msgtql,
 			       unit == IPC_UNIT_DEFAULT ? _(" bytes\n") : "\n", 0);
 		return;
--- a/sys-utils/setarch.c
+++ b/sys-utils/setarch.c
@@ -277,6 +277,10 @@
     argv++;
     if (!strcmp(p, "-h") || !strcmp(p, "--help"))
       show_help();
+  #if defined(__sparc64__) || defined(__sparc__)
+  } else if (!strcmp(p,"sparc64")) {
+      options |= ADDR_LIMIT_32BIT;
+  #endif
     else if (!strcmp(p, "-V") || !strcmp(p, "--version"))
       show_version();
     else if (!strcmp(p, "--list")) {
--- a/term-utils/Makemodule.am
+++ b/term-utils/Makemodule.am
@@ -21,6 +21,9 @@
 dist_man_MANS += term-utils/agetty.8
 agetty_SOURCES = term-utils/agetty.c
 agetty_LDADD = $(LDADD) libcommon.la
+if HAVE_UTIL
+agetty_LDADD += -lutil
+endif
 endif # BUILD_AGETTY
 

--- a/term-utils/agetty.c
+++ b/term-utils/agetty.c
@@ -42,6 +42,12 @@
 #include "widechar.h"
 #include "ttyutils.h"
 
+#if defined(__FreeBSD_kernel__)
+#include <pty.h>
+#include <sys/param.h>
+#endif
+
+
 #ifdef __linux__
 #  include <sys/kd.h>
 #  include <sys/param.h>
@@ -73,6 +79,10 @@
 #  endif
 #endif
 
+#ifdef __FreeBSD_kernel__
+#define USE_SYSLOG
+#endif
+
 /* If USE_SYSLOG is undefined all diagnostics go to /dev/console. */
 #ifdef	USE_SYSLOG
 #  include <syslog.h>
@@ -1056,6 +1066,10 @@
 	if (tcgetattr(STDIN_FILENO, tp) < 0)
 		log_err(_("%s: failed to get terminal attributes: %m"), tty);
 
+#if defined(__FreeBSD_kernel__)
+    login_tty (0);
+#endif
+
 #if defined (__s390__) || defined (__s390x__)
 	if (!op->term) {
 	        /*
